/* util file */
#ifndef UTILITY_H

#define UTILITY_H

#define _HEADER "# The Following Lines are generated by the gentity tool \n# based on the input given in the entitytypes.xml file\n\n\n\n"


#define TS_HEADER "// The Following Lines are generated by the gentity tool \n// based on the input given in the entitytypes.xml file\n\n\n\n"


/* 
   given a string split it into two token ; namely 
   attrbute and its value based on '=' delimiter
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "./structure.h"

typedef struct dict _d;
typedef _d* _d_t;

/* struct to store attribute-value pair and return it to callee */
struct dict{
  char* key;
  char *value;
  int end;
};

_d_t split(char * word){
  printf("UTIL: %s \n",word);
  /* kick of "/" if present in the strlenth of word given */
 
  _d_t my_d = (_d_t) malloc(sizeof(_d));

  my_d->end = 0;
  
  int i=0;
  while(word[i] != '\0'){
    if(word[i] == '/') {my_d->end=1;}
    if(word[i] == '='){
      word[i++] = '\0';
      my_d->key = malloc(sizeof(char) * strlen(word)+1); 
      my_d->key = word;

      my_d->value = &(word[i]);
     
    }
    i++;
  }
  
  return my_d;
 
}

int validate_token(char* curr_word){
  /* if not a valid token return 0 else 1 */
  
  if( (strcmp(curr_word, "Name") == 0) ||  (strcmp(curr_word, "Description") == 0) ||  (strcmp(curr_word, "Persistent") == 0) ||  (strcmp(curr_word, "Parent") == 0) ||  (strcmp(curr_word, "ParentRelation") == 0) ||  (strcmp(curr_word, "") == 0) || (strcmp(curr_word, "AttrDescription") == 0) ||  (strcmp(curr_word, "AttrName") == 0) ||  (strcmp(curr_word, "Type") == 0) )


    return 1;
  return 0;
}


void  pluralise_word(char* input_string){
  int n;
  n=strlen(input_string);
  if (input_string[n - 1] == 'y') //ends with y
    {
      input_string[n + 2] = '\0';
      input_string[n - 1] = 'i';
      input_string[n] = 'e';
      input_string[n + 1] = 's';

    }
  // MISSING ELSE HERE!!!!
  else if (input_string[n - 1] == 's' || ((input_string[n - 2] == 's') && (input_string[n - 1] == 'h'))) // ends with s or sh
    {
      input_string[n] = 'e';
      input_string[n + 1] = 's';
      input_string[n + 2] = '\0';
    }
  else //other cases
    {
      input_string[n] = 's';
      input_string[n + 1] = '\0';
    }

}

void to_upper(char* string)
{
    const char OFFSET = 'a' - 'A';
        (*string >= 'a' && *string <= 'z') ? *string -= OFFSET : *string;
}

/* find entity in container struct */
int find_entity(en_c_t container, char * entity){
  for(int i=0;i < container->en_idx; i++){

    if(strcmp (container->entity[i].name, entity ) == 0){
      printf("Found @ %d",i);
      return i;
    }

  }
  return -1;
}

#endif
